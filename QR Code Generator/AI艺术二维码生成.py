# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h00oAeb_EFm-tHVTlaME_CUpQHMCYJeH
"""

# 适配Colab T4 GPU的环境配置
!pip install -q torch>=2.1.0 torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
!pip install -q diffusers>=0.27.0 transformers>=4.38.0 accelerate>=0.27.0
!pip install -q qrcode>=7.4.2 Pillow>=10.2.0 requests>=2.31.0 gradio>=3.48.0
!pip install -q huggingface_hub>=0.21.0 xformers>=0.0.23  # xformers优化T4显存

# 检查GPU配置
import torch
print(f"GPU型号: {torch.cuda.get_device_name(0)}")
print(f"CUDA版本: {torch.version.cuda}")

import os
import random
import json
import requests
from hashlib import md5
from PIL import Image
import qrcode
import torch
from gradio import (
    Blocks, Textbox, Image as GradioImage, Slider,
    Button, Examples, Checkbox, Accordion, Row, Column,
    Markdown, Gallery, Number
)
from diffusers import StableDiffusionControlNetPipeline, ControlNetModel, UniPCMultistepScheduler

# 1. 安装必要依赖（首次运行自动安装）
!pip install -q torch>=2.1.0 diffusers>=0.27.0 transformers>=4.38.0 accelerate>=0.27.0
!pip install -q qrcode Pillow requests gradio xformers

# 2. 设备配置（强制GPU加速）
device = "cuda" if torch.cuda.is_available() else "cpu"
if device != "cuda":
    raise RuntimeError("请在Colab中启用GPU：修改→笔记本设置→硬件加速器选择T4 GPU")
dtype = torch.float16  # 适配T4显存

# 3. 加载公开模型（无需登录）
controlnet = ControlNetModel.from_pretrained(
    "monster-labs/control_v1p_sd15_qrcode_monster",
    torch_dtype=dtype,
    use_safetensors=True
).to(device)

pipe = StableDiffusionControlNetPipeline.from_pretrained(
    "CompVis/stable-diffusion-v1-4",
    controlnet=controlnet,
    torch_dtype=dtype,
    safety_checker=None,
    use_safetensors=True
).to(device)

# 优化推理速度
pipe.scheduler = UniPCMultistepScheduler.from_config(pipe.scheduler.config)
pipe.enable_xformers_memory_efficient_attention()  # T4 GPU加速

# 4. 工具函数
def resize_for_condition_image(input_image: Image, resolution: int):
    input_image = input_image.convert("RGB")
    W, H = input_image.size
    k = resolution / min(H, W)
    H, W = int(round(H * k / 64) * 64), int(round(W * k / 64) * 64)
    return input_image.resize((W, H), Image.LANCZOS)

def translate(query):
    try:
        # 百度翻译API（可选，失败不影响）
        appid = '20241229002240718'
        appkey = 'UJ3uhuX_gzQV8LMwwVTf'
        from_lang = "zh"
        to_lang = "en"
        url = "http://api.fanyi.baidu.com/api/trans/vip/translate"

        salt = random.randint(32768, 65536)
        sign = md5(f"{appid}{query}{salt}{appkey}".encode()).hexdigest()
        payload = {
            "appid": appid, "q": query, "from": from_lang,
            "to": to_lang, "salt": salt, "sign": sign
        }
        r = requests.post(url, params=payload)
        return r.json()["trans_result"][0]["dst"]
    except:
        return query  # 翻译失败时返回原提示词

# 5. 核心生成函数
def generate_qrcode(
    qr_content, prompt, negative_prompt,
    num_images, width, height, steps,
    guidance, control_strength, noise_strength,
    seed, eta, init_img, qr_img, use_qr_as_init
):
    if not prompt:
        raise ValueError("请输入提示词！")
    prompt_en = translate(prompt)

    # 生成或处理二维码
    if not qr_img or (isinstance(qr_img, Image) and qr_img.size == (1, 1)):
        qr = qrcode.QRCode(
            version=1, error_correction=qrcode.ERROR_CORRECT_H,
            box_size=10, border=4
        )
        qr.add_data(qr_content)
        qr.make(fit=True)
        qr_img = qr.make_image(fill_color="black", back_color="white")

    qr_img = resize_for_condition_image(qr_img, min(width, height))
    init_img = qr_img if use_qr_as_init else init_img
    if init_img:
        init_img = resize_for_condition_image(init_img, min(width, height))

    # 种子处理
    base_seed = random.randint(0, 10**18) if seed == -1 else seed

    # 生成多张图片
    results = []
    for i in range(num_images):
        generator = torch.Generator(device).manual_seed(base_seed + i)
        with torch.no_grad():
            output = pipe(
                prompt=prompt_en,
                negative_prompt=negative_prompt,
                image=qr_img,
                generator=generator,
                width=width,
                height=height,
                guidance_scale=guidance,
                controlnet_conditioning_scale=control_strength,
                eta=eta,
                num_inference_steps=steps,
                strength=noise_strength,
                init_image=init_img if init_img else None
            )
        results.append(output.images[0])

    return prompt_en, results

# 6. 构建网页界面
with Blocks(title="AI艺术二维码生成器") as demo:
    Markdown("""
    # 🎨 AI艺术二维码生成器
    ### 点击下方链接进入网页操作，支持：
    - 自定义二维码内容与艺术风格
    - 调节参数控制生成效果
    - 一次生成多张图片对比
    """)

    with Row():
        # 左侧：参数设置区
        with Column(scale=1):
            # 二维码内容
            Markdown("#### 1. 二维码内容（必填）")
            qr_content = Textbox(
                label="输入网址或文本",
                placeholder="例如：https://www.example.com"
            )

            # 图像设置
            with Accordion("2. 图像与初始设置", open=True):
                Markdown("可上传自定义二维码（不上传则自动生成）")
                qr_img = GradioImage(type="pil", label="自定义二维码")
                use_qr_as_init = Checkbox(True, label="用二维码作为初始图像")
                init_img = GradioImage(type="pil", label="自定义初始图像", visible=False)

                # 动态显示初始图像上传框
                def toggle_init(checked):
                    return gr.update(visible=not checked)
                use_qr_as_init.change(toggle_init, use_qr_as_init, init_img)

            # 提示词
            with Accordion("3. 提示词设置", open=True):
                Markdown("描述艺术风格（例如：「星空下的海洋，梵高风格」）")
                prompt = Textbox(label="中文提示词")
                prompt_en = Textbox(label="英文提示词（自动翻译）", interactive=False)
                Markdown("需要避免的内容（如模糊、低质量）")
                negative_prompt = Textbox(
                    label="负面提示词",
                    value="ugly, blurry, low quality, nsfw, text"
                )

            # 生成参数
            with Accordion("4. 高级参数调节", open=True):
                num_images = Slider(1, 4, 1, 1, label="生成数量")
                width = Slider(512, 1024, 768, 64, label="宽度（64倍数）")
                height = Slider(512, 1024, 768, 64, label="高度（64倍数）")
                steps = Slider(20, 80, 40, 5, label="推理步数")

                guidance = Slider(1, 20, 7.5, 0.5, label="提示词权重")
                control_strength = Slider(0.5, 3, 1.2, 0.1, label="控制网强度（越高二维码越清晰）")
                noise_strength = Slider(0.7, 1.0, 0.9, 0.01, label="噪声强度（越高艺术感越强）")

                eta = Number(0.0, label="采样随机性（0为确定）")
                seed = Slider(-1, 10**18, -1, 1, label="种子（-1为随机）", randomize=True)

            # 生成按钮
            generate_btn = Button("🚀 生成艺术二维码", variant="primary", size="lg")

        # 右侧：结果展示区
        with Column(scale=1):
            Markdown("### 生成结果（点击可下载）")
            result_gallery = Gallery(
                label="艺术二维码",
                columns=2,
                rows=2,
                object_fit="contain",
                height="auto"
            )

    # 绑定生成事件
    generate_btn.click(
        fn=generate_qrcode,
        inputs=[
            qr_content, prompt, negative_prompt,
            num_images, width, height, steps,
            guidance, control_strength, noise_strength,
            seed, eta, init_img, qr_img, use_qr_as_init
        ],
        outputs=[prompt_en, result_gallery]
    )

    # 示例参考
    with Accordion("📌 示例（点击可直接使用）", open=False):
        Examples(
            examples=[
                [
                    "https://colab.research.google.com/",
                    "赛博朋克城市，霓虹灯光，雨夜，高楼",
                    "ugly, blurry",
                    2, 768, 768, 40, 7.5, 1.3, 0.9, -1, 0.0, None, None, True
                ],
                [
                    "https://github.com/",
                    "莫奈风格睡莲，印象派，光影，水面",
                    "ugly, blurry",
                    2, 768, 768, 50, 8.0, 1.1, 0.85, -1, 0.0, None, None, True
                ]
            ],
            inputs=[
                qr_content, prompt, negative_prompt,
                num_images, width, height, steps,
                guidance, control_strength, noise_strength,
                seed, eta, init_img, qr_img, use_qr_as_init
            ],
            outputs=[prompt_en, result_gallery]
        )

# 7. 启动网页服务（生成可点击链接）
demo.queue(max_size=10).launch(
    share=True,  # 生成公开可访问的临时链接
    debug=False,
    server_name="0.0.0.0"
)

